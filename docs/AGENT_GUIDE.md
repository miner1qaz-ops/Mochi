# Mochi v2 – Agent Guide

This is a clean rebuild of the Mochi real‑world‑asset Pokémon card platform for Solana devnet. Use this guide as the orientation doc for future agents.

## High-level architecture
- **On-chain (Anchor):** `mochi_v2_vault` program manages vault state, card records, pack sessions, and marketplace listings. NFTs use Metaplex Core assets. Treasury & escrow are owned by a PDA `vault_authority`.
- **Backend (FastAPI):** Transaction builder + provably-fair RNG service + DB mirror (SQLite/Postgres). Uses Helius DAS for reads. Scripts live in `/scripts`.
- **Frontend (Next.js App Router):** Wallet adapter + animated UI for gacha, marketplace, profiles, admin. Calls backend for previews/tx builders.
- **Data:** Card templates loaded from the Mega Evolution CSV via `scripts/import_card_templates.py`; mint records mirror Core assets sitting in the vault PDA. PNG/JSON metadata lives under `/var/www/mochi-assets/nft` and is exposed through `https://mochims.fun/nft/...` (generated by `~/nft_pipeline`).

## Price Oracle (pokemonTCG.io → PriceSnapshot)
- Source: pokemonTCG.io `/v2/cards` (includes `tcgplayer.prices.market/mid/low/high`). Direct API calls from this VPS are still flaky; preferred flow remains “fetch elsewhere + import.”
- **Append-only rule:** PriceSnapshot is now time-series only. Never delete/overwrite rows; every fetch inserts a new row with the scrape timestamp. The table was purged/reset on 2025-12-05 to clear corrupted data.
- Schema: new columns `market_price` (recent sales) and `direct_low` (lowest listing) plus an index on `(template_id, collected_at)`. Fair value priority = `market_price` → `direct_low` → `mid_price` → `low/high`. Confidence is LOW when `(high - low) / low > 50%` or data is stale.
- APIs: `/pricing/card/{id}` (returns `fair_value` + `confidence_score`), `/pricing/card/{id}/history?points=30` (fair_value per point), `/pricing/sparklines?template_ids=1,2&points=30`, `/pricing/stats?wallet=` (portfolio_total + 24h_change), `/pricing/portfolio` (per-card breakdown with fair_value/confidence).
- Relevant files: `scripts/fetch_tcg_prices.py` (supports `POKEMONTCG_PROXY`), `price_oracle/config.json`, sample payload `/root/me1.json`.

### Refreshing prices (append-only)
1) On a machine with API access, fetch a set as JSON (includes collected_at implicitly):
```
curl --http1.1 -s -H "Accept: application/json" \
  -H "X-Api-Key: <API_KEY>" \
  "https://api.pokemontcg.io/v2/cards?q=set.id:<SET_ID>&page=1&pageSize=250&select=name,set,tcgplayer,rarity" \
  -o <set>.json
```
For Mega Evolution: `set.id:me1`, pageSize 250 covers all 188 cards.

2) Upload JSON to VPS: `scp <set>.json root@72.61.126.168:/root/mochi/`.

3) Import (append) on VPS using the script (sets live in `price_oracle/config.json`):
```
POKEMONTCG_API_KEY=<API_KEY> PRICE_ORACLE_CONFIG=price_oracle/config.json \
  python3 scripts/fetch_tcg_prices.py
```
This maps rows by fuzzy card/set name to CardTemplate and inserts `market_price`, `direct_low`, `mid/low/high`, and `collected_at` timestamps. No deletes are performed; each run adds new time-series points.

If you must scrape from the VPS directly, set `POKEMONTCG_PROXY` and rerun the same script (falls back to Playwright/scrapy via the vendored `price_oracle/pokespider`).

## Key flows
- **Pack opening:**
  1) Frontend calls `/program/open/preview` with client seed to show rarities.
  2) `/program/open/build` selects specific assets (DB/Helius), builds `open_pack_start` tx.
  3) User signs; decision window = 1 hour. `claim_pack` or `sellback_pack` txs are built by backend.
- **Pack opening v2 (Rare+ only on-chain):**
  - New `pack_session_v2` PDA holds only Rare+ CardRecord bindings (max 3); Common/Uncommon/Energy stay off-chain in the DB.
  - `open_pack` (v2) reserves Rare+ CardRecords, `claim_pack_v2`/`sellback_pack_v2` resolve, `expire_session_v2` frees after the window, and `admin_force_close_v2` clears stuck sessions.
  - SessionMirror now keeps `template_ids` and `version=2` for hybrid inventory; VirtualCard table tracks low-tier counts; recycle endpoint mints Mochi tokens from recycled low-tier cards.
- **Marketplace:** Listings stored on-chain via `Listing` PDA; backend provides tx builders; frontend renders grid & actions.
  - Mainnet hardening (todo): enforce a verified collection/update-authority/creator allowlist when accepting deposits/listings so only Mochi-minted assets can be escrowed. Today the program doesn’t gate the Core asset beyond CardRecord ownership; add collection/creator checks before mainnet.
- **Profiles:** Read holdings via Helius DAS filtered by Core collection; enrich with CSV template metadata.
- **Admin:** Inventory by rarity, session mirrors, cleanup/settle helpers.

## Seeds / PDAs
- `vault_state`: [`"vault_state"`]
- `vault_authority`: [`"vault_authority"`, vault_state]
- `card_record`: [`"card_record"`, vault_state, core_asset]
- `pack_session`: [`"pack_session"`, vault_state, user]
- `listing`: [`"listing"`, vault_state, core_asset]

## Environment
- Devnet-first. RPC via Helius (set `HELIUS_RPC_URL`).
- Wallets: generated keypairs live in `anchor-program/keys/`. `passkey.json` is the authority key; `program-id.json` is the program deploy key.
- Treasury: set `TREASURY_WALLET` (defaults to `PLATFORM_WALLET`) for marketplace fees/buyback payouts.
- Backend tx builders return message base64 (`tx_b64`), unsigned v0 tx (`tx_v0_b64`), instruction metadata, and `recent_blockhash` for client signing.
- RNG provably-fair: `server_seed_hash` (commit), `server_nonce = sha256(server_seed_hash:client_seed)[:16]`, entropy = `sha256(server_seed:client_seed:server_nonce)`. Preview/build return `server_seed_hash`, `server_nonce`, and `entropy_proof` so users can verify slot lineups.
- Timekeeping: prefer ISO-8601 (`YYYY-MM-DDTHH:MM:SSZ`). Install MCP time server (`pip install mcp-server-time` or `uvx mcp-server-time`) to keep logs accurate; see `docs/mcp_time.md`.
- Devnet defaults (generated): CORE_AUTHORITY/VAULT wallet `CKjhhqfijtAD48cg2FDcDH5ARCVjRiQS6ppmXFBM6Lcs`, USDC mint `GWRsfsckjMn2vRZjUf3756AdZiNJULG6E6oTvbK6SvRu`. Secrets in `anchor-program/keys/dev-authority.json` and `dev-usdc-mint.json`.

## Toolchain (Docker, use this for builds)
- Image: build once from repo root `docker build -f Dockerfile.anchor -t anchor-dev .`
- Versions baked in: `solana-cli 1.18.20`, `anchor-cli 0.30.1`, `rustc/cargo 1.91.1`.
- Run container for builds/deploys:
```
docker run --rm -it \
  -v /root/mochi:/workspace \
  -v /root/mochi/anchor-program/keys:/root/.config/solana \
  -w /workspace/anchor-program \
  anchor-dev bash
```
- Inside: `anchor clean && anchor build --program-name mochi_seed_sale --arch sbf`, then `anchor deploy --program-name mochi_seed_sale --provider.cluster devnet`.
- MSRV pin: the SBF toolchain is rustc `1.75.x`; keep `Cargo.lock` at version 3 and run `rustup default 1.75.0` in the container before `anchor build/deploy`. `Cargo.toml` patches pin `toml_*`, `indexmap`, and `borsh( -derive)` to MSRV-compatible versions—avoid bumping them or regenerating the lockfile with newer Cargo.

## Minting verification checklist
- Core assets (Metaplex): use Helius DAS `getAsset` on a minted `core_asset`; expect `ownership.owner = vault_authority` and metadata URI matching `https://mochims.fun/nft/metadata/...`. Admin refresh: `curl -X POST http://127.0.0.1:8000/admin/inventory/refresh` then `curl http://127.0.0.1:8000/admin/inventory/assets | jq 'length'` to see counts; CardRecords should show `status=Available`.
- SPL mints (e.g., USDC/Mochi token): `spl-token supply <mint>`, `spl-token account-info <mint> --owner <wallet>`; confirm decimals, mint/freeze authority, and balances for treasury/vault ATAs.
- Deposit confirmation: `anchor accounts mochi_v2_vault` (or `solana account <card_record_pda>`) shows CardRecord status/owner; backend SessionMirror shouldn’t list them as reserved.
- Explorer check: view the mint/asset in Solscan/Explorer for final confirmation of supply/owner/metadata.
- **Seed sale (devnet test)**
  - Program: `2mt9FhkfhrkC5RL29MVPfMGVzpFR3eupGCMqKVYssiue`
  - PDAs (authority `CKjhhqfijtAD48cg2FDcDH5ARCVjRiQS6ppmXFBM6Lcs`, mint `2iL86tZQkt3MB4iVbFwNefEdTeR3Dh5QNNxDfuF16yjT`): sale `8S39Fqt73RvakApyQq7mcnPQTQ7MqKVRB4Y6JRzaWviY`, vault auth `J8kvs3vE6mFFhceA59khvkhtKAx4wZQN4xmSfF73j4P7`, seed vault `9pSNuqZjx15rzc9mP4tvFGcZYJrczDtLMm6B19s3trY5`.
  - Init tx: `5bR86vLzYqN9WHsdnmZukaUAwmgBdYQ3u7wCDGv3nJG2JdX1Sa93FiWArY4fZivzUoDsCJPPNr2dGd5tVXFFFBde`; seed vault funded with full devnet supply (sig `24wdtitnJRCu5mKXjzd3BFMH4QaYc7yMNW2Y8UaA3JnKG5eppRY99G7FT1JFWVd9VLhSAvMnxHtdLAb5uyBCUyqT`).

## Repos & folders
```
/mochi
  anchor-program   (Anchor code + IDL + keys)
  backend          (FastAPI + models + tx builders)
  frontend         (Next.js/Tailwind/Framer/wallet adapter)
  scripts          (CSV importer, mint + deposit helpers)
  docs             (this guide and per-surface docs)
```

## Dev conventions
- Use devnet program id `Gc7u33eCs81jPcfzgX4nh6xsiEtRYuZUyHKFjmf5asfx`.
- Keep docs in `/docs` updated whenever you change code or flows.
- Prefer Helius DAS for reads; Anchor RPC for writes.
- Provably-fair RNG = `sha256(server_seed:client_seed)` → deterministic RNG; store `server_seed_hash` in responses.

## Useful commands
- Backend dev: `cd backend && uvicorn main:app --reload --port 8000`
- Frontend dev: `cd frontend && npm install && npm run dev`
- Import templates: `DATABASE_URL=sqlite:///backend/mochi.db python scripts/import_card_templates.py ../nft_pipeline/data/mega-evolutions.csv`
- Asset pipeline: `cd ../nft_pipeline && npm run fetch:tcgdex && npm run generate && npm run upload -- --target local`
- Mint + deposit Core assets: `CORE_TEMPLATE_OFFSET=0 CORE_TEMPLATE_LIMIT=40 TS_NODE_TRANSPILE_ONLY=1 npx ts-node -P tsconfig.scripts.json scripts/mint_and_deposit.ts`
- Refresh backend inventory mirror: `curl -X POST http://127.0.0.1:8000/admin/inventory/refresh`
- Claim flow (dev): use `/program/claim/batch_flow` (per-card txs + finalize) or `/program/claim/test3` for a 3-card benchmark; single-shot claim is disabled. Always send the returned txs sequentially and finalize afterward.
- Pricing oracle:
  - Folder: `price_oracle/` (pokespider vendoring), config at `price_oracle/config.json` (`{"sets": ["Base Set", ...]}`).
  - Fetch script: `scripts/fetch_tcg_prices.py` (requires Scrapy/Playwright; `playwright install chromium`). Inserts append-only rows with `market_price`, `direct_low`, `mid/low/high`, and `collected_at`; never delete existing snapshots.
  - Fair value: priority `market_price → direct_low → mid_price`; `confidence_score` flips LOW when `(high-low)/low > 50%` or stale. Endpoints return `fair_value` + sparkline points: `/pricing/card/{id}`, `/pricing/card/{id}/history?points=30`, `/pricing/sparklines?template_ids=1,2`, `/pricing/stats?wallet=`, `/pricing/portfolio`.
  - Buyback: sellback build still uses 90% of mid-price converted via `get_sol_price` (mock 150 USD/SOL). On-chain program needs payout override support; rarity-based fallback remains.
  - If API is blocked from the VPS: fetch on another machine then import JSON:
    1) `curl --http1.1 -s -H "Accept: application/json" -H "X-Api-Key: <API_KEY>" "https://api.pokemontcg.io/v2/cards?q=set.id:<SET_ID>&page=1&pageSize=250&select=name,set,tcgplayer,rarity" -o <set>.json`
    2) Upload to VPS (`/root/mochi/`) and import via a short Python snippet mapping (card name + set name) → `CardTemplate` and replacing `PriceSnapshot` rows for that set.
  - Derived fields: backend pricing responses return `display_price`, 7d/30d averages, spread ratio, `price_confidence`; frontend pricing page shows display + confidence and a detail modal with sparkline (90d).
- Listing rescue:
  - Script: `scripts/rescue_garbage.ts` calls on-chain `admin_force_cancel_listing` to return NFTs from an old/non-canonical `vault_state` to the seller (no DB writes).
  - Input: JSON array `[{"listing": "...", "vault_state": "...", "seller": "...", "core_asset": "..."}, ...]` (e.g., from `/admin/marketplace/garbage`).
  - Usage:
    ```
    PAYER=/path/to/admin.json RPC_URL=https://api.devnet.solana.com \
      ts-node scripts/rescue_garbage.ts /path/to/garbage.json
    ```
    Derives PDAs with the OLD vault_state (`vault_authority`, `card_record`, `listing`) and sends `admin_force_cancel_listing`. Ensure admin keypair matches `vault_state.admin` of the old vault; adjust MPL Core program id in the script if needed.

## Contact points
- Admin address: set via env `ADMIN_ADDRESS` / `NEXT_PUBLIC_ADMIN_ADDRESS`.
- Core collection: set via env `CORE_COLLECTION_ADDRESS`.

Keep this guide current as the stack evolves and when adding VRF, payments, or redemption flows.
